package integerBreak;

/**
 * No.343 整数拆分
 *
 * 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
 * 返回 你可以获得的最大乘积 。
 */

public class Solution {

    /**
     * 动规
     */
    // // 时间复杂度：O(n^2)
    // // 空间复杂度：O(n)
    // public int integerBreak(int n) {
    //     // 1. dp[i] 表示正整数i拆分后的最大乘积
    //     int[] dp = new int[n + 1];
    //
    //     // 2. 递推公式：dp[i] = max{dp[i], j * (i-j), j * dp[i-j]}， j从1开始遍历
    //
    //     // 3. 初始化
    //     dp[2] = 1;
    //
    //     // 4. 遍历顺序：从前往后
    //     for (int i = 3; i <=n; i++) {
    //         // 对每一个i，先拆一个j出来，有两种可能：j直接和另一个数(i-j)相乘或者(i-j)继续拆分，求两种可能的最大值作为当前j值拆法的d[i]最大值
    //         // 遍历每一个j，求出所有j可能的最大值作为d[i]最终的最大值
    //         for (int j = 1; j < i-1; j++) { // 为什么j不取到i-1？——其实j=i-1，另一个数就为1，这个j值得d[i]最大为(i-1)*1，1无法再拆，这种情况在j=1时其实已经考虑过了，并且dp[1]我们认为没有意义，因此这里就不写到i-1了
    //             dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));
    //         }
    //     }
    //     return dp[n];
    // }


    /**
     * 动规
     * 因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。（数学可证明）
     * 因此dp[i]的最大值一定出现在相近的子数相乘，而题目规定最少要拆成2个数的和，所以j取到 i/2 就可以了，j取后面更大的数不可能是更大的dp[i]
     * 如果拆成3个数的和，那么j取到 i/3 就可以了，而 i/3 在j从1遍历到 i/2 的路上已经被考虑进去了
     */
    // // 时间复杂度：O(n^2)
    // // 空间复杂度：O(n)
    // public int integerBreak(int n) {
    //     // 1. dp[i] 表示正整数i拆分后的最大乘积
    //     int[] dp = new int[n + 1];
    //
    //     // 2. 递推公式：dp[i] = max{dp[i], j * (i-j), j * dp[i-j]}， j从1开始遍历
    //
    //     // 3. 初始化
    //     dp[2] = 1;
    //
    //     // 4. 遍历顺序：从前往后
    //     for (int i = 3; i <=n; i++) {
    //         // 对每一个i，先拆一个j出来，有两种可能：j直接和另一个数(i-j)相乘或者(i-j)继续拆分，求两种可能的最大值作为当前j值拆法的d[i]最大值
    //         // 遍历每一个j，求出所有j可能的最大值作为d[i]最终的最大值
    //         for (int j = 1; j <= i / 2; j++) {
    //             dp[i] = Math.max(dp[i], Math.max(j * (i-j), j * dp[i-j]));
    //         }
    //     }
    //     return dp[n];
    // }


}
