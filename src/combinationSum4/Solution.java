package combinationSum4;

/**
 * No.377  组合总和 Ⅳ
 *
 * 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
 * 题目数据保证答案符合 32 位整数范围。
 * 请注意，顺序不同的序列被视作不同的组合。
 */


/**
 * 在求装满背包有几种方案的时候，认清遍历顺序是非常关键的：
 * 1. 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
 * 理解：若先遍历物品，再遍历背包，假设物品有a,b,c三种，那么最后选择出的组合中只能按照abc的顺序，b根本没机会放到a的前面，
 * 因为先遍历完a确定了各个容量j时a是否放入的组合数，结束后才遍历b的，此时确定各容量j下b是否放入的组合数，即使b放入，也只会放在a的后面。
 * （先遍历物品再遍历背包在遍历物品时其实隐含着限制了物品放入的顺序，也就是限制了最后组合中物品的前后顺序）
 *
 * 2. 如果求排列数就是外层for遍历背包，内层for循环遍历物品。
 * 理解：若先遍历背包，再遍历物品，这样每种物品放入背包的顺序就不固定了。假设对于某个背包容量j，依次检查每种物品是否能放入，如果a不合适，
 * 但是b合适并被放入，随着遍历背包容量变大，说不定原来的a又适合装入了，这样就有了不同的顺序了。
 * 由于每个数值可以被选择无限次，因此在计算任意总和时，我们保证 nums 中的每一位都会被考虑到即可（即确保对组合总和 target 的遍历在外，对数组 nums 的遍历在内）。
 */


public class Solution {

    /**
     * 完全背包 + 一维滚动数组
     * 注意：说是求组合的个数，但又说顺序不同的序列被视作不同的组合，因此实际是求排列数
     * 完全背包且使用一维滚动数组优化空间复杂度需要注意：
     * 1. 递推公式和求装满背包的组合数相同
     * 2. 两个for循环的顺序必须先遍历背包容量，再遍历物品
     * 3. 遍历背包容量必须顺序遍历（保证可以重复添加同一个数）
     *
     * 关于完全背包问题求装满背包时的排列数，二维dp的递推公式推导见下面的链接（与装满背包时的组合数递推公式并不相同）
     * 链接：https://leetcode.cn/problems/combination-sum-iv/solutions/740651/gong-shui-san-xie-yu-wan-quan-bei-bao-we-x0kn/
     *
     * @param nums
     * @param target
     * @return
     */
    public int combinationSum4(int[] nums, int target) {
        int len = nums.length;
        // dp[j]：从nums中选择和为j的不同排列数
        int[] dp = new int[target + 1];

        // 递推公式：dp[j] = dp[j] + dp[j-nums[i]]

        // 初始化，由于target是正整数，故dp[0]其实是没有意义的，dp[0]=1完全是为了递推公式能够正确推导
        dp[0] = 1;

        // 遍历顺序：求排列数，必须先遍历背包容量，再遍历物品
        // 理解：由于每个数值可以被选择无限次，因此在计算任意总和时，我们保证 nums 中的每一位都会被考虑到即可（即确保对组合总和 target 的遍历在外，对数组 nums 的遍历在内）。
        // 这样，对每一个固定的容量j，都会从头到尾考虑每一个物品在本轮被放入的可能性，累加所有物品的可能性就是这个j值下所有得到排列数
        // for (int j = 0; j <= target; j++) {
        //     for (int i = 0; i < len; i++) {
        //         if (j >= nums[i]) {
        //             dp[j] += dp[j-nums[i]];
        //         }
        //     }
        // }

        for (int j = 1; j <= target; j++) { // dp[0]其实全是1，所以从1开始即可
            for (int n : nums) {    // 对每一个固定的容量j，都会从头到尾考虑每一个物品在本轮被放入的可能性
                if (j >= n) {
                    dp[j] += dp[j - n];
                }
            }
        }

        return dp[target];
    }


    /**
     * 动态规划，爬楼梯
     * 看成总共target层楼梯，每次爬楼梯可以爬nums中的一个数那么多层，问总共有几种爬法
     * @param nums
     * @param target
     * @return
     */
    // public int combinationSum4(int[] nums, int target) {
    //     // dp[i]：爬到i层的爬法数
    //     int[] dp = new int[target + 1];
    //
    //     // 递推公式：dp[i] = Σ(dp[i-nums[k]])，对每个i都遍历一遍nums中所有的数
    //
    //     // 初始化，可以看作爬到0层一步都不爬也算作一种爬法
    //     dp[0] = 1;
    //
    //     // 遍历顺序：求dp[i]依赖于前面的dp，因此i从前往后遍历，即爬到高层的爬法数依赖于爬较低层的爬法数，因此从低往高求
    //     for (int i = 1; i <= target; i++) {
    //         for (int num : nums) {
    //             if (i >= num) {
    //                 dp[i] += dp[i - num];
    //             }
    //         }
    //     }
    //
    //     return dp[target];
    // }

}
