package maxProfit_309;

/**
 * No.309 买卖股票的最佳时机含冷冻期
 *
 * 给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。
 * 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
 * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 *
 * 本题特点：
 * 1. 买卖次数不限制，可以尽可能多次交易，但想再次购买前必须出售掉之前购买的股票
 * 2. 卖出股票后的第二天无法买入
 * 与No.122类似，加入了冷冻期的限制
 */

public class Solution {


    /**
     * 动态规划 + 二维dp
     * @param prices
     * @return
     */
    // // 时间复杂度：O(n)，其中n为prices数组的长度
    // // 空间复杂度：O(n)，其中n为prices数组的长度。分析：dp数组总大小为2n
    // public int maxProfit(int[] prices) {
    //     int n = prices.length;
    //     if (n == 1) {
    //         return 0;
    //     }
    //
    //     // dp[i][0]：第i天持有股票的情况下手里最多的现金
    //     // dp[i][1]：第i天不持有股票的情况下手里最多的现金
    //     // 因为不限制最多交易次数，因此只用管每天结束时是否持有股票即可，dp数组第二维只用定义两个状态，至于究竟是不是在冷冻期就交给递推过程自己选择
    //     int[][] dp = new int[n][2];
    //
    //     // 递推公式
    //     // dp[i][0] = max{dp[i-1][0], dp[i-2][1] - prices[i]}，第i天结束时持有股票分为两种情况：
    //     // 1. 前一天就持有了，不是今天买入的，保持前一天的状态，即dp[i-1][0]
    //     // 2. 前一天不持有，则是今天买入的，由于冷冻期的存在，只能是 再前一天的不持有状态 - 第i天买股票花的钱
    //     //
    //     // dp[i][1] = max{dp[i-1][1], dp[i-1][0] + prices[i]}，第i天结束时不持有股票分为两种情况：
    //     // 1. 前一天就不持有，今天手里本来就没有股票，并不是今天卖出才没有的，保持前一天的状态，即dp[i-1][1]
    //     // 2. 前一天是持有的，则是今天卖出，所以是 前一天的持有状态 + 第i天卖股票赚的钱
    //
    //     // 初始化，由于计算dp[i]要用到dp[i-1]和dp[i-2]，所以要初始化前两天的状态，且for循环从i=2开始遍历
    //     dp[0][0] = -prices[0];  // 第0天买入
    //     dp[0][1] = 0;   // 第0天没买
    //     dp[1][0] = Math.max(-prices[0], -prices[1]);    // 可能是第0天买入，也可能是第1天买入的
    //     dp[1][1] = Math.max(0, prices[1] - prices[0]);  // 可能没买过，也可能第0天买了第1天卖出
    //
    //     // 遍历顺序：从前往后
    //     for (int i = 2; i < n; i++) {   // 从第2天开始
    //         dp[i][0] = Math.max(dp[i-1][0], dp[i-2][1] - prices[i]);
    //         dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
    //     }
    //
    //     return dp[n-1][1];
    // }


    /**
     * 动态规划 + 滚动变量
     * 优化空间复杂度
     * @param prices
     * @return
     */
    // 时间复杂度：O(n)，其中n为prices数组的长度
    // 空间复杂度：O(1)
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 1) {
            return 0;
        }

        // dp[0]：某天持有股票的情况下手里最多的现金
        // dp[1]：某天不持有股票的情况下手里最多的现金
        int[] dp = new int[2];

        // 递推公式
        // dp[i][0] = max{dp[i-1][0], dp[i-2][1] - prices[i]}，第i天结束时持有股票分为两种情况：
        // 1. 前一天就持有了，不是今天买入的，保持前一天的状态，即dp[i-1][0]
        // 2. 前一天不持有，则是今天买入的，由于冷冻期的存在，只能是 再前一天的不持有状态 - 第i天买股票花的钱
        //
        // dp[i][1] = max{dp[i-1][1], dp[i-1][0] + prices[i]}，第i天结束时不持有股票分为两种情况：
        // 1. 前一天就不持有，今天手里本来就没有股票，并不是今天卖出才没有的，保持前一天的状态，即dp[i-1][1]
        // 2. 前一天是持有的，则是今天卖出，所以是 前一天的持有状态 + 第i天卖股票赚的钱

        // 初始化，由于计算dp[i]要用到dp[i-1]和dp[i-2]，所以要初始化前两天的状态，且for循环从i=2开始遍历
        int[] pre2 = {-prices[0], 0};  // 前天的状态（i-2），初始为第0天
        int[] pre1 = {Math.max(-prices[0], -prices[1]), Math.max(0, prices[1] - prices[0])};    // 昨天的状态（i-1），初始为第1天

        // 遍历顺序：从前往后
        for (int i = 2; i < n; i++) {   // 从第2天开始
            dp[0] = Math.max(pre1[0], pre2[1] - prices[i]);
            dp[1] = Math.max(pre1[1], pre1[0] + prices[i]);

            // 向后推进一天，更新pre2和pre1
            // 昨天变前天
            pre2[0] = pre1[0];
            pre2[1] = pre1[1];
            // 今天变昨天
            pre1[0] = dp[0];
            pre1[1] = dp[1];
        }

        // 注意这里要返回pre1[1]而不是dp[1]，因为可能n=2只有两天，此时dp数组还都是默认值，应该按照初始化的pre1即第1天结束来返回
        // 至于n>2的情况，肯定会进入for循环，最后pre1其实是更新成了dp才跳出循环的，因此返回pre1也是正确的
        return pre1[1];
    }
}
