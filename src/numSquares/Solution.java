package numSquares;

import java.util.Arrays;

/**
 * No.279 完全平方数
 *
 * 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
 * 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
 */

public class Solution {

    /**
     * 完全背包 + 二维dp
     * @param n
     * @return
     */
    // public int numSquares(int n) {
    //     int max = n + 1;    // 不考虑0的话最多需要n个数（即n个1），因此将max设的比n大一点即可，代表无法凑成n的情况。不用MAX_VALUE是避免后面+1溢出
    //     // 物品数组：{0, 1, 4, 9,...}，最多到10000，即数组长度最多101，下标i对应的完全平方数为i^2
    //
    //     // dp[i][j]：从 0~i 中挑选和为j的完全平方数的最少数量为dp[j]
    //     int[][] dp = new int[101][n + 1];   // 符合条件的完全平方数最多到100^2，因此物品数组长度设到101即可满足本题范围
    //
    //     // 递推公式：dp[i][j] = min{dp[i-1][j], dp[i][j-nums[i]] + 1}
    //
    //     // 初始化
    //     Arrays.fill(dp[0], max);    // 只用0来凑一个和为正整数n，需要用无限多的0都凑不够
    //     dp[0][0] = 0;   // 凑金额0最少不要硬币，因此第零列都是0，实际n不会取到0，这里这么初始化完全是为了递推的正确
    //
    //     // 遍历顺序，都可以，这里用先物品，再背包
    //     for (int i = 1; i <= 100; i++) {
    //         for (int j = 0; j <= n; j++) {  // 二维dp这里的j得从0开始正序遍历，因为 j < nums[i] 的情况还需要为dp[i][j]赋值dp[i-1][j]
    //             // 如果是一维滚动数组且内循环为背包容量，则j可以从nums[i]开始正序遍历，因为 j < nums[i]的部分会自动沿用之前的
    //             dp[i][j] = dp[i-1][j];
    //             if (j >= i * i) {
    //                 dp[i][j] = Math.min(dp[i-1][j], dp[i][j-i*i] + 1);
    //             }
    //         }
    //     }
    //
    //     return dp[100][n];  // 因为本问题一定有解（起码n个1是可以凑成的），实际上dp内大于等于max的数最终都会被有效值覆盖，不要判断直接返回即可
    // }


    /**
     * 完全背包 + 一维滚动数组优化
     * @param n
     * @return
     */
    public int numSquares(int n) {
        int max = n + 1;    // 不考虑0的话最多需要n个数（即n个1），因此将max设的比n大一点即可，代表无法凑成n的情况。不用MAX_VALUE是避免后面+1溢出
        // 物品数组：{0, 1, 4, 9,...}，最多到10000，即数组长度最多101，下标i对应的完全平方数为i^2

        // dp[j]：挑选和为j的完全平方数的最少数量为dp[j]
        int[] dp = new int[n + 1];

        // 递推公式：dp[j] = min{dp[j], dp[j-nums[i]] + 1}

        // 初始化
        Arrays.fill(dp, max);    // 只用0来凑一个和为正整数n，需要用无限多的0都凑不够
        dp[0] = 0;   // 凑金额0最少不要硬币，实际n不会取到0，这里这么初始化完全是为了递推的正确

        // 遍历顺序，都可以，这里用先物品，再背包
        for (int i = 1; i * i <= n; i++) {    // 0不用考虑，因为0的增加只会使答案变大，求最少硬币一定不会有0，从数1（对应下标1）开始考虑即可。当nums[i] = i^2 已经超过n则一定无法被加入
            for (int j = i * i; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j-i*i] + 1);
            }
        }


        // 先遍历背包，再遍历物品
        // for (int j = 1; j <= n; j++) {
        //     for (int i = 1; i * i <= j; i++) {  // 物品重量i*i不能超过容量j
        //         dp[j] = Math.min(dp[j], dp[j-i*i] + 1);
        //     }
        // }

        return dp[n];  // 因为本问题一定有解（起码n个1是可以凑成的），实际上dp内大于等于max的数最终都会被有效值覆盖，不要判断直接返回即可
    }



    /**
     * 动态规划 + 爬楼梯（好理解）
     * 每步可以选择爬 1，4，9... 完全平方数那么多级楼梯，求爬到第 n 级楼梯最少需要几步
     * @param n
     * @return
     */
    // public int numSquares(int n) {
    //     int max = n + 1;    // 不考虑0的话最多需要n个数（即n个1），因此将max设的比n大一点即可，代表无法凑成n的情况。不用MAX_VALUE是避免后面+1溢出
    //     // 物品数组：{0, 1, 4, 9,...}，最多到10000，即数组长度最多101，下标i对应的完全平方数为i^2
    //
    //     // dp[i]：爬到第i级楼梯的最少需要dp[i]步
    //     int[] dp = new int[n + 1];
    //
    //     // 对于每一个目标层数i，考虑最后一步的所有可能，求最小值
    //     // 递推公式：dp[i] = min{dp[i - k*k] + 1}，k*k为一步可能爬的阶梯数
    //
    //     // 初始化
    //     Arrays.fill(dp, max);    // 初始时都是max步，为无效值，保证求出有效结果时一定能覆盖初始值
    //     dp[0] = 0;   // 爬到0级不需要走，即0步
    //
    //     // 遍历顺序：从下往上求到达每一级阶梯i的最少步数
    //     for (int i = 1; i <= n; i++) {
    //         for (int k = 1; k * k <= i; k++) {  // 对于爬到第i级楼梯考虑最后一步的所有可能，如果一步k*k超过了i则不用考虑了
    //             dp[i] = Math.min(dp[i], dp[i - k * k] + 1);
    //         }
    //     }
    //
    //     return dp[n];
    // }



}
