package maxProfit_123;

import java.util.Arrays;

/**
 * No.123 买卖股票的最佳时机Ⅲ
 *
 * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
 * 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 *
 * 与Ⅰ的区别：可以最多完成2笔交易，但最多只能同时持有一股，所以再次购买前要出售掉之前的股票
 */

public class Solution {


    /**
     * 动态规划 + 三维dp
     *
     * @param prices
     * @return
     */
    // // 时间复杂度：O(n)，其中n为prices数组的长度
    // // 空间复杂度：O(n)，其中n为prices数组的长度
    // public int maxProfit(int[] prices) {
    //     int n = prices.length;
    //
    //     // dp[i][0][k]：第i天结束持有股票且还能购买k次情况下的最多现金（k=0或1）
    //     // dp[i][1][k]：第i天结束不持有股票且还能购买k次情况下的最多现金（k=0或1或2）
    //     int[][][] dp = new int[n][2][3];
    //
    //     // 递推公式：
    //     // 1. 对于k=0或1，dp[i][0]和dp[i][1]都要计算：
    //     // dp[i][0][k] = max{dp[i-1][0][k], dp[i-1][1][k+1] - prices[i]}
    //     // dp[i][1][k] = max{dp[i-1][1][k], dp[i-1][0][k] + prices[i]}
    //     // 2. 对于k=2，只有dp[i][1]有意义，需要计算：（因为dp[i][0][2]代表第i天结束持有股票且还能购买2次，这不满足题目最多购买两次的要求）
    //     // dp[i][1][2] = 0，第i天不持有且还能购买两次说明到第i天为止都还没买过股票，当然也就没花钱没赚钱，手里的现金为0（保持初始值就好）
    //
    //     // 初始化，从前往后递推，只需要初始化第0天的dp[0]即可
    //     dp[0][0][0] = -prices[0];   // 本来不可能出现，理解为第0天买了又卖，然后第二次买入持有
    //     dp[0][0][1] = -prices[0];   // 第0天第一次买入的情况
    //     dp[0][1][0] = 0;    // 本来不可能出现，这里理解为第0天买了又卖，买了又卖，两次机会用掉然后不持有
    //     dp[0][1][1] = 0;    // 本来不可能出现，这里理解为第0天买了又卖，第二次机会还没用
    //     dp[0][1][2] = 0;    // 第0天没有买入的情况
    //
    //     for (int i = 1; i < n; i++) {
    //         for (int k = 0; k < 2; k++) {
    //             dp[i][0][k] = Math.max(dp[i - 1][0][k], dp[i - 1][1][k + 1] - prices[i]);
    //             dp[i][1][k] = Math.max(dp[i - 1][1][k], dp[i - 1][0][k] + prices[i]);
    //         }
    //         // dp[i][1][2] = 0; 到第i天为止还没买入过的情况，手里还是0元，保持默认值即可
    //     }
    //
    //     // return Math.max(dp[n-1][1][0], Math.max(dp[n-1][1][1], dp[n-1][1][2])); // 最后一天不持有股票肯定是利润最大的
    //     return dp[n - 1][1][0]; // 这里其实直接返回两次卖出后的最大利润即可，因为另外两种情况包含在里面
    //     // 解释：如果一次都不买利润最大（dp[n-1][1][2]），即价格持续下降，最好的结果是不买入，利润为0，那么可以看作在同一天买入又卖出两次，可以买卖两次的情况考虑进去
    //     // 如果第一次卖出已经是最大值了（dp[n-1][1][1]），那么我们可以在当天立刻买入再立刻卖出，也可以被买卖两次的情况考虑进去
    // }


    /**
     * 动态规划 + 二维dp
     * 其实跟上一种写法没有本质区别，只是上一种将每天结束时还能购买股票的次数跟下标（k）关联起来，并放在了第三个维度，最终第二维和第三维合起来的有效状态也就是5个
     *
     * 这里直接将每天结束时的五种可能状态定义在第二个维度。
     * 由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：
     * -0 未进行过任何操作；
     * -1 只进行过一次买操作；
     * -2 进行了一次买操作和一次卖操作，即完成了一笔交易；
     * -3 在完成了一笔交易的前提下，进行了第二次买操作；
     * -4 完成了全部两笔交易。
     *
     * 无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这是因为这一操作带来的收益为零。
     *
     * @param prices
     * @return
     */
    // // 时间复杂度：O(n)，其中n为prices数组的长度
    // // 空间复杂度：O(n)，其中n为prices数组的长度
    // public int maxProfit(int[] prices) {
    //     int n = prices.length;
    //
    //     // dp[i][j]：第i天结束时处于状态j的情况下手里的最多现金为dp[i][j]（j=0~4）
    //     int[][] dp = new int[n][5];
    //
    //     // 递推公式：
    //     // dp[i][0] = 0，到第i天为止还没买卖过，保持0元
    //     // dp[i][1] = max{dp[i-1][1], -prices[i]}，可能第i-1天及之前就已经第一次买入了，也可能第i天才第一次买入
    //     // dp[i][2] = max{dp[i-1][2], dp[i-1][1] + prices[i]}，可能第i-1天及之前就已经买卖过一次了，也可能第i天才第一次卖出
    //     // dp[i][3] = max{dp[i-1][3], dp[i-1][2] - prices[i]}，可能第i-1天及之前就已经第二次买入了，也可能第i天才第二次买入
    //     // dp[i][4] = max{dp[i-1][4], dp[i-1][3] + prices[i]}，可能第i-1天及之前就已经买卖过两次了，也可能第i天才第二次卖出
    //
    //
    //     // 初始化，从前往后递推，只需要初始化第0天即可
    //     // 在考虑边界条件时，我们需要理解：无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响
    //     dp[0][0] = 0;   // 还没买过
    //     dp[0][1] = -prices[0];   // 第0天第一次买入的情况
    //     dp[0][2] = 0;    // 这里理解为第0天第一次买入并且卖出
    //     dp[0][3] = -prices[0];    // 这里理解为第0天买入并且卖出后再以prices[0]的价格买入股票
    //     dp[0][4] = 0;    // 这里理解为第0天两次买入又卖出
    //
    //     for (int i = 1; i < n; i++) {
    //         // dp[i][0] = 0; 默认值为0，可不写
    //         dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    //         dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i]);
    //         dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i]);
    //         dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i]);
    //     }
    //
    //     return dp[n-1][4]; // 这里其实直接返回两次卖出后的最大利润即可，因为另外两种情况包含在里面
    // }


    /**
     * 动态规划 + 滚动变量
     * 优化空间复杂度
     * @param prices
     * @return
     */
    // 时间复杂度：O(n)，其中n为prices数组的长度
    // 空间复杂度：O(1)
    public int maxProfit(int[] prices) {
        int n = prices.length;

        // dp[j]：某天结束处于状态j的情况下手里的最多现金为dp[j]（j=0~4）
        int[] dp = new int[5];

        // 递推公式：
        // dp[0] = 0
        // dp[1] = max{pre1, -prices[i]}
        // dp[2] = max{pre2, pre1 + prices[i]}
        // dp[3] = max{pre3, pre2 - prices[i]}
        // dp[4] = max{pre4, pre3 + prices[i]}


        // 初始化，prei代表前一天结束时处于状态i的最大现金，初始时pre代表第0天
        // dp[0]一直是0，也不会参与计算，可以不管
        int pre1 = -prices[0];
        int pre2 = 0;
        int pre3 = -prices[0];
        int pre4 = 0;

        // 从前往后遍历
        for (int i = 1; i < n; i++) {
            dp[1] = Math.max(pre1, -prices[i]);
            dp[2] = Math.max(pre2, pre1 + prices[i]);
            dp[3] = Math.max(pre3, pre2 - prices[i]);
            dp[4] = Math.max(pre4, pre3 + prices[i]);

            // 更新pre
            pre1 = dp[1];
            pre2 = dp[2];
            pre3 = dp[3];
            pre4 = dp[4];
        }

        // 最后一天不持有股票肯定是利润最大的，所以应该在pre0，pre2，pre4中选最大值
        // 但是由于允许在同一天买入并且卖出并不会影响结果，且pre2和pre4初始化为了0，
        // 所以最优情况出现在不交易或恰好一笔交易时也会转移到两笔交易的情况，即若pre0,pre2最大则pre4也会记录到这个最大值
        return dp[4]; // 这里其实直接返回两次卖出后的最大利润即可，因为另外两种情况包含在里面
    }
}
