package nextPermutation;

import java.util.Arrays;

/**
 * No.31 下一个排列
 *
 * 整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
 * - 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
 *
 * 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，
 * 那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的
 * 排列（即，其元素按升序排列）。
 * - 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
 * - 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
 * - 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
 *
 * 给你一个整数数组 nums ，找出 nums 的下一个排列。
 * 必须 原地 修改，只允许使用额外常数空间。
 */
public class Solution {


    /**
     * 希望下一个排列更大，但是增加的幅度尽可能小，因此需要：
     * 尽可能只改动靠右的低位，因此需要从后往前找
     *
     * 为了使增加的幅度尽可能小：
     * 第一次循环从右向左找到第一个递减的数nums[head]，使得改动的后半序列的长度尽可能小
     * 第二次循环从右向左找到比nums[head]大的最小的数与其交换，使得增长最小
     *
     * @param nums
     */
    // 时间复杂度：O(n)
    // 时间复杂度：O(1)
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int head = -1;  // 指向从后往前第一个

        // 首先从后往前遍历：
        // 1. 从右向左升序则继续向前找，因为当前升序这部分已经是局部最大序列，只改动这部分是不够找到更大序列的，如 3，2，1
        // 2. 当找到第一个递减的数，则它就是需要改动的后半部分的第一个，用head标记，如 1，3，2，1，那么只用改动这四个数的顺序就能找到符合题意的
        for(int i = n - 1; i > 0; i--) {
            if(nums[i-1] < nums[i]) {
                head = i - 1;
                break;
            }
        }

        // 如果head找到了从右往左第一个递减的数，那么再从右往左找到比该数大的第一个数，如 1，3，2，1中从右往左比1大的第一个数是2
        // 将该数与head指向的数交换，变成 2，3，1，1
        if (head != -1) {
            for (int j = n - 1; j > head; j--) {
                if(nums[j] > nums[head]) {
                    swap(nums, j, head);
                    break;
                }
            }
        }

        // 交换完后head右边的序列一定是递减序列，如 3，1，1
        // 如果整个序列从右往左递减，那么head=-1，head+1=0，需要将整个序列翻转
        // 那么用双指针首尾交换将它们反转就得到了递增序列，如 1，1，3
        for(int i = head + 1, j = n - 1; i < j; i++, j--) {
            swap(nums, i, j);
        }

        // 最后结果 x, x, 2, 1, 1, 3
    }


    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
