package maxProfit_122;

/**
 * No.122 买卖股票的最佳时机Ⅱ
 *
 * 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
 * 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。
 * 返回 你能获得的最大利润 。
 *
 * 与Ⅰ的区别：
 * 1. 可以多次购买和卖出，但最多只能同时持有一股，所以再次购买前要出售掉之前的股票
 * 2. 可以在同一天买入和卖出（事实上在同一天买卖没有意义，因为这样利润为0，不如这天不买入）
 */

public class Solution {


    /**
     * 动态规划
     *
     * 本题和 No.121 唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况：
     * 在No.121中，因为股票全程只能买卖一次，所以如果选择在第i天买入股票，那么第i天持有股票即dp[i][0]的后一项一定就是-prices[i]。
     * 而本题，因为一只股票可以买卖多次，所以第i天买入股票的时候，可能会有之前买卖的利润即：dp[i - 1][1]，因而dp[i][0]的后一项为dp[i-1][1] - prices[i]
     * @param prices
     * @return
     */
    // // 时间复杂度：O(n)
    // // 空间复杂度：O(n)。虽然看起来像二维dp，但有一维的长度为固定值2
    // public int maxProfit(int[] prices) {
    //     int n = prices.length;
    //
    //     // dp[i][0] 表示第i天持有股票的情况下手里最多有多少现金（i从0开始）
    //     // dp[i][1] 表示第i天不持有股票的情况下手里最多还有多少现金
    //     // 注意：这些值可能为负数，比如手里没有钱，第i天买入，则第i天结束时手里的现金就为-prices[i]
    //     int[][] dp = new int[n][2];
    //
    //     // 递推公式
    //     // 1. 第i天持有股票的情况：dp[i][0] = max{dp[i-1][0], dp[i-1][1] - prices[i]}，可以由两个状态推导：
    //     // - 第i-1天就已经持有股票了，所以第i天持有的股票不是在当天买的，也就是第i天没有花钱。所以第i天结束时手里的钱等于 前一天持有股票结束的情况手里的现金
    //     // - 第i-1天时还没有持有股票，所以第i天持有的股票是在第i天当天买入的，也就是第i天花了钱。所以第i天结束时手里的钱等于 前一天结束不持有股票情况的最大现金 - 第i天买股票花的钱
    //     // 2. 第i天不持有股票的情况：dp[i][1] = max{dp[i-1][1], dp[i-1][0] + prices[i]}，可以由两个状态推导：
    //     // - 第i-1天也不持有股票，所以第i天不持有股票是因为本来手里就没有，而不是当前卖掉才没有，也就是第i天没有赚钱。所以第i天结束时手里的钱还等于 前一天不持有股票结束的情况手里的现金
    //     // - 第i-1天时还持有股票，所以第i天不再持有股票意味着在当天卖出了，也就是第i天赚了钱。所以第i天结束时手里的钱等于 前一天结束还持有股票情况的最大现金 + 第i天卖股票赚的钱
    //
    //     // 初始化
    //     dp[0][0] = -prices[0];  // 第0天持有一定是当天买入的
    //     dp[0][1] = 0;   // 第0天不持有一定是还没开始买
    //
    //     // 遍历顺序：从前往后
    //     for (int i = 1; i < n; i++) {
    //         dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
    //         dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
    //     }
    //
    //     return dp[n-1][1];  // 最后一天卖出股票收益高于持有股票收益，因此取[1]
    // }




    /**
     * 动态规划 + 滚动数组优化 （通用）
     *
     * 从递推公式可以看出，dp[i]只依赖于前一项dp[i-1]，因此用一个长度为2的滚动数组记录即可，在计算的同时不断更新
     * @param prices
     * @return
     */
    // // 时间复杂度：O(n)
    // // 空间复杂度：O(1)
    // public int maxProfit(int[] prices) {
    //     int n = prices.length;
    //
    //     // dp[0] 表示第i天持有股票的情况下手里最多有多少现金（i从0开始）
    //     // dp[1] 表示第i天不持有股票的情况下手里最多还有多少现金
    //     // 注意：这些值可能为负数，比如手里没有钱，第i天买入，则第i天结束时手里的现金就为-prices[i]
    //     int[] dp = new int[2];
    //
    //     // 递推公式
    //     // 1. 第i天持有股票的情况：dp[0] = max{dp[0], dp[1] - prices[i]}
    //     // 2. 第i天不持有股票的情况：dp[1] = max{dp[1], dp[0] + prices[i]}
    //
    //     // 初始化
    //     dp[0] = -prices[0];  // 第0天持有一定是当天买入的
    //     dp[1] = 0;   // 第0天不持有一定是还没开始买
    //
    //     // 遍历顺序：从前往后
    //     for (int i = 1; i < n; i++) {
    //         // 这里先用两个临时变量记录前一天的dp[0]和dp[1]
    //         // 因为按照递推公式求dp[0]和dp[1]，如果先计算完今天的dp[0]直接赋值就会将前一天的dp[0]覆盖了，再计算今天的dp[1]时又需要用到前一天的dp[0]
    //         int lastKeep = dp[0];   // 前一天持有股票的情况手里最大现金
    //         int lastLose = dp[1];   // 前一天不持有股票的情况手里最大现金
    //         dp[0] = Math.max(lastKeep, lastLose - prices[i]);
    //         dp[1] = Math.max(lastLose, lastKeep + prices[i]);
    //     }
    //
    //     return dp[1];  // 最后一天卖出股票收益高于持有股票收益，因此取[1]
    // }


    /**
     * 针对本题，还可以用贪心算法
     * 贪心算法的直觉：由于不限制交易次数，只要今天股价比昨天高，就交易。
     * 讲解：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solutions/12625/best-time-to-buy-and-sell-stock-ii-zhuan-hua-fa-ji
     *
     * 关键：
     * 对于连续上涨交易日，第一天买最后一天卖收益最大，等价于每天都买卖
     * 对于不上涨的日子，不买入收益最大，不买就不会亏
     *
     * @param prices
     * @return
     */
    // 时间复杂度：O(n)
    // 空间复杂度：O(1)
    public int maxProfit(int[] prices) {
        int res = 0;

        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i-1]) {  // 只要发现今天比昨天价格高，则昨天买入，今天卖出（上帝视角，可以反悔）
                res += (prices[i] - prices[i-1]);
            }
        }

        return res;
    }
}
