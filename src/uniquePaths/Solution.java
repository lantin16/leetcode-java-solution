package uniquePaths;

/**
 * No.62 不同路径
 *
 * 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
 * 问总共有多少条不同的路径？
 */

public class Solution {

    /**
     * 动态规划
     */
    // // 时间复杂度：O(mn)
    // // 空间复杂度：O(mn)
    // public int uniquePaths(int m, int n) {
    //     // dp[i][j]表示从(0,0)出发到达坐标(i,j)的格子有多少不同的路径
    //     int[][] dp = new int[m][n];
    //
    //     // 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]
    //
    //     // 写法一：只初始化dp[0][0]，在双循环内部就得先判断左和上是否越界再加
    //     // // 初始化
    //     // dp[0][0] = 1;
    //     //
    //     // // 遍历顺序：从左往右、从上往下
    //     // for (int i = 0; i < m; i++) {
    //     //     for (int j = 0; j < n; j++) {
    //     //         if (i-1 >= 0) {
    //     //             dp[i][j] += dp[i-1][j];
    //     //         }
    //     //         if (j-1 >= 0) {
    //     //             dp[i][j] += dp[i][j-1];
    //     //         }
    //     //     }
    //     // }
    //
    //
    //     // 写法二：由于只能向右向下走，因此到达第一行和第一列的格子都只有一种路径，所以可以直接将它们初始化为1，这样在循环内部就不用判断越界问题
    //     for (int i = 0; i < m; i++) {
    //         dp[i][0] = 1;
    //     }
    //
    //     for (int j = 0; j < n; j++) {
    //         dp[0][j] = 1;
    //     }
    //
    //     // 因为第一行和第一列的dp元素都初始化了，因此下面直接从第二行第二列计算，访问左和上时也就不会出现越界
    //     for (int i = 1; i < m; i++) {
    //         for (int j = 1; j < n; j++) {
    //             dp[i][j] = dp[i-1][j] + dp[i][j-1];
    //         }
    //     }
    //
    //     return dp[m-1][n-1];
    // }



    /**
     * 动态规划，利用滚动数组优空间复杂度
     * 简要来说就是通过观察dp方程来判断需要使用哪些数据，可以抛弃哪些数据，一旦找到关系，就可以用新的数据不断覆盖旧的数据量来减少空间的使用。
     */
    // 时间复杂度：O(mn)
    // 空间复杂度：O(n)
    public int uniquePaths(int m, int n) {
        // dp[j]表示从(0,0)出发到达坐标(i,j)的格子有多少不同的路径，每计算完一行就可以覆盖上一行的dp数组（）
        int[] dp = new int[n];

        // 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1]

        // dp[]初始存储第一行的dp[j]
        for (int j = 0; j < n; j++) {
            dp[j] = 1;
        }

        // 从第二行开始计算
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {   // 每一行的dp[0]都是1，因此不用覆盖也行，故从第二列开始计算dp[j]
                dp[j] = dp[j-1] + dp[j];    // 计算dp[j]时后面的dp[j-1]已经是这一行覆盖过来的，而dp[j]仍然是上一行j列的
            }
        }

        return dp[n-1];
    }
}
